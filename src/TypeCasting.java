
 public class TypeCasting 
 {
 public static void main(String[]args)

 {
	 
	 //for typecasting refer slides provided by udemy course..
	 //Implicit typecasting:conversion of small datatype to big data type
	 
	 /*short x=5;
	 int y=x;
	 System.out.println(y);*///that is we can store the value of  4bit into 8 bit
	 
	/* int x=5;
	 short y=x;//cannot convert from int to short that s why we use explicit typecasting this is problem.. solution write in next
	 System.out.println(x);
	 
	 solution is explicite typecasting
	/* int x=5;
	 short y=(short)x;
	  System.out.println(x);
	 
	   
	 int x=5;
	 short y=(byte)x;
	 System.out.println(y);
	 
	 float v1=10.0f;
	 double v2=20.0d;
	 System.out.println(v2);
	 
	 
	 
	 
	 double v2=20.0d;
	 float v1=v2;//double to float conversion  is not possible because double has a high precision entity..so we have to typecast
	 System.out.println(v1);
	 
	 //solution is
	 double v2=20.0d;
	 float v1=(float)v2;
	 System.out.println(v1);

	 
	 double v2=20.0123456789d;
	 float v1=(float)v2;
	 System.out.println(v1);//we get output 20.012346 from this result we know that its truncated value..float cant take thi smuch precision 
	 
	 
	 String x="10";
	 int y=(int)x;//we cant cast string to int and vice versa
	 
	 
	 float x=10.0f;
	 int y=(int)x;
	 System.out.println(y);
	 
	  long i=10l;
	 float f=i;
	 System.out.println(f);//output is 10.0 its possible to conver long to float
	 
	 
	 float f=10.0f;
	 long l=f;
	 System.out.println(l);//cannot convert float to long thats why we have to typecast 
	 
	 //solution
	 float f=10.0f;
	 long l=(long)f;
	 System.out.println(l);
	 
	 	float f=10.532f;
	 long l=(long)f;
	 System.out.println(l);//output is 10 because after decimal value is truncated
	 
	 //into float is possible but float to int not passible
	  */

	
	 

	 
	 
	 
	 
	
	 
	 
	 
	 
	 
	 
 }
}

 